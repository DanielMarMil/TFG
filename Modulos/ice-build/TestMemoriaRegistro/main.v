// Code generated by Icestudio 0.6.0

`default_nettype none

//---- Top entity
module main #(
 parameter vadc080 = "vadc080.list",
 parameter vaf2f89 = 11,
 parameter v2dea3b = "v2dea3b.list",
 parameter v54ba2f = "v54ba2f.list",
 parameter vcc1bd8 = "vcc1bd8.list"
) (
 input v4f6099,
 input vclk,
 output v715944,
 output v653f1c,
 output v9fc178,
 output [0:5] vinit
);
 localparam p2 = vaf2f89;
 localparam p5 = v2dea3b;
 localparam p7 = v54ba2f;
 localparam p12 = vcc1bd8;
 localparam p13 = vadc080;
 wire w0;
 wire w1;
 wire w3;
 wire w4;
 wire [0:7] w6;
 wire [0:7] w8;
 wire [0:7] w9;
 wire [0:7] w10;
 wire [0:5] w11;
 wire [0:5] w14;
 wire w15;
 wire [0:7] w16;
 wire [0:31] w17;
 wire [0:7] w18;
 wire [0:7] w19;
 wire [0:7] w20;
 wire w21;
 wire [0:5] w22;
 wire [0:31] w23;
 wire [0:31] w24;
 wire [0:31] w25;
 wire [0:5] w26;
 wire w27;
 wire w28;
 wire w29;
 wire w30;
 wire [0:5] w31;
 wire [0:5] w32;
 assign w0 = v4f6099;
 assign v9fc178 = w0;
 assign w1 = v4f6099;
 assign v715944 = w15;
 assign v653f1c = w21;
 assign w28 = vclk;
 assign w29 = vclk;
 assign w30 = vclk;
 assign w1 = w0;
 assign w8 = w6;
 assign w9 = w6;
 assign w9 = w8;
 assign w10 = w6;
 assign w10 = w8;
 assign w10 = w9;
 assign w20 = w6;
 assign w20 = w8;
 assign w20 = w9;
 assign w20 = w10;
 assign w22 = w14;
 assign w25 = w17;
 assign w26 = w11;
 assign w27 = w3;
 assign w29 = w28;
 assign w30 = w28;
 assign w30 = w29;
 assign w32 = w31;
 vb0c93d v608128 (
  .vbc3322(w15),
  .v5f0bab(w16),
  .vd8ecb5(w17),
  .va73833(w18),
  .v97eecd(w19),
  .v68ad21(w20),
  .v516a7d(w21),
  .v9856bd(w23),
  .v489ac8(w24),
  .v805d19(w28)
 );
 ve2b856 v7d4db6 (
  .vd9601b(w1),
  .v64879c(w3),
  .vbbbce8(w29)
 );
 v725b7e v8b8c4e (
  .v9fb85f(w4)
 );
 vd014cb #(
  .v5e4a03(p2)
 ) vf4765f (
  .vdd729a(w3),
  .v7c533e(w4),
  .vb86fe4(w6)
 );
 main_v9fb13f #(
  .opmemory(p5)
 ) v9fb13f (
  .in(w6),
  .Read_Reg_1(w14)
 );
 main_v07915a #(
  .funcionmemory(p7)
 ) v07915a (
  .in(w8),
  .Read_Reg_2(w11)
 );
 main_vc54226 #(
  .write_data_reg(p13)
 ) vc54226 (
  .in(w9),
  .Write_Data(w17)
 );
 main_vaf73f3 #(
  .write_reg_mem(p12)
 ) vaf73f3 (
  .in(w10),
  .Write_Reg(w31)
 );
 main_v98c0e8 v98c0e8 (
  .in(w11),
  .out(w18)
 );
 main_v559759 v559759 (
  .in(w14),
  .out(w16)
 );
 main_v845edd v845edd (
  .out(w19),
  .in(w31)
 );
 v2040f6 vd8fc68 (
  .ve2e442(w22),
  .v70ed7b(w23),
  .vff4be9(w24),
  .v7d4d05(w25),
  .v326a87(w26),
  .v51a33d(w27),
  .ve70352(w30),
  .va61a55(w32)
 );
 assign vinit = 6'b000000;
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/
//---- Top entity
module vb0c93d #(
 parameter v56d5e7 = 115200
) (
 input v805d19,
 input v9580da,
 input [31:0] v9856bd,
 input [31:0] v489ac8,
 input [31:0] vd8ecb5,
 input [31:0] v524e22,
 input [7:0] v5f0bab,
 input [7:0] va73833,
 input [7:0] v97eecd,
 input [7:0] v68ad21,
 output vbc3322,
 output v396cc9,
 output v516a7d
);
 localparam p0 = v56d5e7;
 wire [0:7] w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire [0:7] w6;
 wire [0:7] w7;
 wire [0:7] w8;
 wire [0:7] w9;
 wire [0:31] w10;
 wire [0:31] w11;
 wire [0:31] w12;
 wire [0:31] w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 assign vbc3322 = w4;
 assign v396cc9 = w5;
 assign w6 = v68ad21;
 assign w7 = v97eecd;
 assign w8 = va73833;
 assign w9 = v5f0bab;
 assign w10 = v524e22;
 assign w11 = vd8ecb5;
 assign w12 = v489ac8;
 assign w13 = v9856bd;
 assign w14 = v9580da;
 assign w15 = v805d19;
 assign w16 = v805d19;
 assign w17 = v805d19;
 assign v516a7d = w19;
 assign w16 = w15;
 assign w17 = w15;
 assign w17 = w16;
 assign w18 = w3;
 vc6459c #(
  .ved2ada(p0)
 ) v039dc6 (
  .v19b8dd(w1),
  .v05e99b(w2),
  .v01321e(w3),
  .v8caaa5(w4),
  .ve9a78f(w16)
 );
 vb0c93d_v04da77 v04da77 (
  .data_o(w1),
  .txmit_o(w2),
  .next(w3),
  .busy(w5),
  .B3(w6),
  .B2(w7),
  .B1(w8),
  .B0(w9),
  .W3(w10),
  .W2(w11),
  .W1(w12),
  .W0(w13),
  .txmit(w14),
  .clk(w15),
  .done(w19)
 );
 v43c77c vdd720e (
  .vcfc79f(w17),
  .v4c46bf(w18)
 );
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/

module vb0c93d_v04da77 (
 input clk,
 input txmit,
 input [31:0] W0,
 input [31:0] W1,
 input [31:0] W2,
 input [31:0] W3,
 input [7:0] B0,
 input [7:0] B1,
 input [7:0] B2,
 input [7:0] B3,
 input next,
 output [7:0] data_o,
 output txmit_o,
 output busy,
 output done
);
 reg state = 0;
 reg[7:0] data_o;
 reg[4:0] nbyte = 0;
 wire finish;
 
 always @(posedge clk)
   if (txmit)
     state <= 1'b1;
   else if (finish)
     state <= 1'b0;
 
 //-- El estado es directamente la señal de busy    
 assign busy = state;
 
 //-- La señal de done se obtiene por el flanco 
 //-- de bajada en el estado
 
 reg q0 = 0;
 
 always @(posedge clk)
   q0 <= state;
   
 assign done = (q0 & ~state);
 
 //-- Tic inicial: En el arranque del transmisor
 //-- Flanco de subida en el estado
 wire tic_start = (~q0 & state);  
 
 
 //-- Transmision de un byte: en el tic de start y en el tic de next  
 //-- siempre y cuano el transmisor esté habilitado
 assign txmit_o = (tic_start | tic_next) & state;
 
 //-- Cable que contiene el tic siguiente. Se obtiene retrasando dos
 //-- ciclos la señal next
 wire tic_next = q2;
 
 reg q1 = 0;
 reg q2 = 0;
 
 always @(posedge clk) begin
   q1 <= next;
   q2 <= q1;
 end
   
 //--- El dato a enviar se obtiene seleccionando el byte alto o  
 //-- el bajo
 //-- assign data_o = (nbyte) ? data[15:8] : data[7:0];
 always @(posedge clk) 
 begin
     case (nbyte)
         0 : data_o <= W0[31:24];
         1 : data_o <= W0[23:16];
         2 : data_o <= W0[15:8];
         3 : data_o <= W0[7:0];
         4 : data_o <= W1[31:24];
         5 : data_o <= W1[23:16];
         6 : data_o <= W1[15:8];
         7 : data_o <= W1[7:0];
         8 : data_o <= W2[31:24];
         9 : data_o <= W2[23:16];
         10 : data_o <= W2[15:8];
         11 : data_o <= W2[7:0];
         12 : data_o <= W3[31:24];
         13 : data_o <= W3[23:16];
         14 : data_o <= W3[15:8];
         15 : data_o <= W3[7:0];
         16 : data_o <= B0;
         17 : data_o <= B1;
         18 : data_o <= B2;
         19 : data_o <= B3;
     endcase
 end
 
 //-- Biestable T que indica el byte a enviar
 //-- Inicialmente vale 1 (alto)
 
 always @(posedge clk) begin
   if (next)
     nbyte <= nbyte + 1;
   else if (finish)
     nbyte = 0;
     
 end
 //-- Un flanco de subida en nbyte indica que se ha enviado el último
 //-- byte
 
 reg q3 = 0;
 
 always @(posedge clk)
   q3 <= nbyte[4] & nbyte[2];
   
 assign finish = (~q3 & nbyte[4] & nbyte[2]);  
 
 
 
 
 
 
 
 
endmodule
//---- Top entity
module vc6459c #(
 parameter ved2ada = 115200
) (
 input ve9a78f,
 input [7:0] v19b8dd,
 input v05e99b,
 output v8caaa5,
 output v2da441,
 output v01321e
);
 localparam p1 = ved2ada;
 wire w0;
 wire w2;
 wire [0:7] w3;
 wire w4;
 wire w5;
 wire w6;
 assign v8caaa5 = w0;
 assign w2 = ve9a78f;
 assign w3 = v19b8dd;
 assign w4 = v05e99b;
 assign v2da441 = w5;
 assign v01321e = w6;
 vc6459c_vedebcc #(
  .BAUD(p1)
 ) vedebcc (
  .TX(w0),
  .clk(w2),
  .data(w3),
  .txmit(w4),
  .busy(w5),
  .done(w6)
 );
endmodule

/*-------------------------------------------------*/
/*-- Serial-tx  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Transmisor serie
/*-------------------------------------------------*/

module vc6459c_vedebcc #(
 parameter BAUD = 0
) (
 input clk,
 input [7:0] data,
 input txmit,
 output TX,
 output busy,
 output done
);
 //-- Constantes para obtener las velocidades estándares
 `define B115200 104 
 `define B57600  208
 `define B38400  313
 `define B19200  625
 `define B9600   1250
 `define B4800   2500
 `define B2400   5000
 `define B1200   10000
 `define B600    20000
 `define B300    40000
 
 //-- Constante para calcular los baudios
 localparam BAUDRATE = (BAUD==115200) ? `B115200 : //-- OK
                       (BAUD==57600)  ? `B57600  : //-- OK
                       (BAUD==38400)  ? `B38400  : //-- Ok
                       (BAUD==19200)  ? `B19200  : //-- OK
                       (BAUD==9600)   ? `B9600   : //-- OK
                       (BAUD==4800)   ? `B4800   : //-- OK 
                       (BAUD==2400)   ? `B2400   : //-- OK
                       (BAUD==1200)   ? `B1200   : //-- OK
                       (BAUD==600)    ? `B600    : //-- OK
                       (BAUD==300)    ? `B300    : //-- OK
                       `B115200 ;  //-- Por defecto 115200 baudios
 
 
 //---- GENERADOR DE BAUDIOS
 
 //-- Calcular el numero dde bits para almacenar el divisor
 localparam N = $clog2(BAUDRATE);
 
 //-- Contador para implementar el divisor
 //-- Es un contador modulo BAUDRATE
 reg [N-1:0] divcounter = 0;
 
 //-- Cable de reset para el contador
 //-- Comparador que resetea el contador cuando se alcanza el tope
 //-- o cuando el estado del biestable es 0 (apagado)
 wire reset = ov_gen | (state == 0);
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 //-- Hemos llegado al final
 wire ov_gen = (divcounter == BAUDRATE-1);
 
 
 
 //-- REGISTRO DESPLAZAMIENTO
 
 //-- Salida serie. Inicialmete a 1 (reposo) 
 reg TX = 1;
 
 //-- Registro de desplazamiento de 9 bits
 //-- Inicializado todo a 1s
 reg [8:0] q = 9'h1FF;
 
 //-- La entrada de shift es la salida del generador de baudios
 wire shift = ov_gen;
 
 always @(posedge clk)
   if (txmit_tic)
   //-- Carga del registro
     q <= {data, 1'b0};
     
   else if (shift)
     //-- Desplazamiento. Rellenar con 1 (bit de stop)
     q <= {1'b1, q[8:1]};
     
 //-- Sacar el bit de menor peso por serial-out    
 wire so;
 assign so = q[0];
 
 //-- La salida tx la registramos
 always @(posedge clk)
   TX <= so;
   
 //-- La señal de entrada txmit se pasa por un 
 //-- detector de flancos de subida para generar un tic
 reg q_re = 0;
 wire txmit_tic;
 
 always @(posedge clk)
   q_re <= txmit;
   
 assign txmit_tic = (~q_re & txmit);  
 
 
 
 //-- Estado de transmisor
 //-- 0: Parado
 //-- 1: Ocupado (transmitiendo)
 reg state = 0;
   
 always @(posedge clk)
   //-- Empieza la transmision: ocupado
   if (txmit)
     state <= 1'b1;
     
   //-- Acaba la transmision: libre    
   else if (ov)
     state <= 1'b0;
 
 //-- Contador de bits enviados
 reg [3:0] bits = 0;
 always @(posedge clk)
   //-- Si la cuenta ha terminado... volver a 0
   if (ov)
     bits <= 2'b00;
   else
     if (shift)
       bits <= bits + 1;
 
 //-- Comprobar si se ha transmitido el último bit (overflow)
 //-- 1 bit de start + 8 bits de datos + 1 bit de stop
 wire ov = (bits == 10);
 
 //-- La señal de ocupado es el estado del transmisor
 assign busy = state;
 
 //-- La señal de done es la de overflow pero retrasada un
 //-- periodo de reloj del sistema y que el biestable 
 //-- llegue al estado de parado antes de que se 
 //-- empiece otra transmision
 
 reg done=0;
 
 always @(posedge clk)
   done <= ov;
 
endmodule
//---- Top entity
module v43c77c #(
 parameter vf18b7a = 50
) (
 input vcfc79f,
 input v4c46bf,
 output v19f572
);
 localparam p0 = vf18b7a;
 wire w1;
 wire w2;
 wire w3;
 assign v19f572 = w1;
 assign w2 = vcfc79f;
 assign w3 = v4c46bf;
 vf91a27 #(
  .v187a47(p0)
 ) vf1e43e (
  .veabfb2(w1),
  .v5688a8(w2),
  .v6e1dd1(w3)
 );
endmodule

/*-------------------------------------------------*/
/*-- flash  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Emitir un pulso de anchura determinada para encender un LED durante un tiempo. 50ms por defecto
/*-------------------------------------------------*/
//---- Top entity
module vf91a27 #(
 parameter v187a47 = 100
) (
 input v5688a8,
 input v6e1dd1,
 output veabfb2,
 output va9e2af
);
 localparam p4 = v187a47;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = v6e1dd1;
 assign veabfb2 = w1;
 assign va9e2af = w2;
 assign w3 = v5688a8;
 vf91a27_v3140f5 #(
  .MS(p4)
 ) v3140f5 (
  .start(w0),
  .p(w1),
  .tic(w2),
  .clk(w3)
 );
endmodule

/*-------------------------------------------------*/
/*-- timer-msec  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Temporizador en milisegundos. La señal p está activa durante el tiempo indicado. Por tic se emite un tic al finalizar
/*-------------------------------------------------*/

module vf91a27_v3140f5 #(
 parameter MS = 0
) (
 input clk,
 input start,
 output p,
 output tic
);
 //localparam MS;
 
 //-- Constante para dividir y obtener una señal de  
 //-- periodo 1ms
 localparam M = 12000;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Cable de reset para el corazon
 wire rst_heart;
 
 //-- Overflow del temporizador del corazon
 wire ov_heart;
 
 //-- Habilitacion del corazon
 wire ena;
 
 //-- Tics del corazon
 wire tic_heart;
 
 //-- Contador del corazon
 reg [N-1:0] heart=0;
 
 always @(posedge clk)
   if (rst_heart)
     heart <= 0;
   else
     heart <= heart + 1;
 
 //-- Overflow del contador
 assign ov_heart = (heart == M-1);
 
 //-- La salida del corazon es la señal de overflow
 assign tic_heart = ov_heart;
 
 //-- Reset del corazon
 assign rst_heart =~ena | ov_heart;
 
 
 
 //--------------------------------------------
 //-- Contador de tics
 //--------------------------------------------
 
 //-- Calcular el numero de bits para almacenar MS tics
 localparam CB = $clog2(MS);
 
 reg [CB-1:0] counter = 0;
 
 //-- Overflow del contador
 wire ov;
 
 //-- Señal de reset del contador
 wire rst;
 
 always @(posedge clk)
 if (rst)
   counter <= 0;
 else
   if (tic_heart)
     counter <= counter + 1;
 
 //-- Evento: cuenta máxima de tics alcanzada
 assign ov = (counter == MS);
 
 //---------------------------------------
 //-- Biestable de estado del timer
 //-- 0: Apagado  
 //-- 1: Funcionando
 reg q = 0;
 
 always @(posedge clk)
   if (start)
     q <= 1'b1;
   else if (rst)
     q<=1'b0;
     
 //-- Lógica de reset
 //En función de la entrada, el estado y  
 // el overflow se inicializa el contador y 
 // se habilita el corazón de tics
 assign rst = ~q | ov | start;
 assign ena = ~rst;
 
 //-- Salida de pulso
 assign p = q;
 
 //-- Salida de tic
 //-- Saca un tic cuando ha finalizado la cuenta
 assign tic = ov;
 
endmodule
//---- Top entity
module ve2b856 (
 input vbbbce8,
 input vd9601b,
 output v64879c
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = vd9601b;
 assign v64879c = w1;
 assign w2 = vbbbce8;
 ve2b856_v297cb2 v297cb2 (
  .d(w0),
  .tic(w1),
  .clk(w2)
 );
endmodule

/*-------------------------------------------------*/
/*-- Pulsador-tic  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Detección de pulsación. Emite un tic cada vez que se aprieta el pulsador
/*-------------------------------------------------*/

module ve2b856_v297cb2 (
 input clk,
 input d,
 output tic
);
 // Sincronizacion. Evitar 
 // problema de la metaestabilidad
 
 reg d2;
 reg r_in;
 
 always @(posedge clk)
  d2 <= d;
  
 always @(posedge clk)
   r_in <= d2;
 
 
 //-- Debouncer Circuit
 //-- It produces a stable output when the
 //-- input signal is bouncing
 
 reg btn_prev = 0;
 reg btn_out_r = 0;
 
 reg [16:0] counter = 0;
 
 
 always @(posedge clk) begin
 
   //-- If btn_prev and btn_in are differents
   if (btn_prev ^ r_in == 1'b1) begin
     
       //-- Reset the counter
       counter <= 0;
       
       //-- Capture the button status
       btn_prev <= r_in;
   end
     
   //-- If no timeout, increase the counter
   else if (counter[16] == 1'b0)
       counter <= counter + 1;
       
   else
     //-- Set the output to the stable value
     btn_out_r <= btn_prev;
 
 end
 
 //-- Generar tic en flanco de subida del boton
 reg old;
 
 always @(posedge clk)
   old <= btn_out_r;
   
 assign tic = !old & btn_out_r;
 
 
 
 
endmodule
//---- Top entity
module v725b7e (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 v725b7e_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

/*-------------------------------------------------*/
/*-- 1  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Un bit constante a 1
/*-------------------------------------------------*/

module v725b7e_vb2eccd (
 output q
);
 //-- Bit constante a 1
 assign q = 1'b1;
 
 
endmodule
//---- Top entity
module vd014cb #(
 parameter v5e4a03 = 256
) (
 input vdd729a,
 input ve61673,
 input v7c533e,
 output [7:0] vb86fe4,
 output v712cd1
);
 localparam p1 = v5e4a03;
 wire w0;
 wire w2;
 wire w3;
 wire w4;
 wire [0:7] w5;
 assign w0 = ve61673;
 assign w2 = v7c533e;
 assign w3 = vdd729a;
 assign v712cd1 = w4;
 assign vb86fe4 = w5;
 vd014cb_vbd6086 #(
  .M(p1)
 ) vbd6086 (
  .rst(w0),
  .cnt(w2),
  .clk(w3),
  .ov(w4),
  .q(w5)
 );
endmodule

/*-------------------------------------------------*/
/*-- Contador-8bits-up-rst  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Contador módulo M, ascendente, de 8 bits, con reset 
/*-------------------------------------------------*/

module vd014cb_vbd6086 #(
 parameter M = 0
) (
 input clk,
 input rst,
 input cnt,
 output [7:0] q,
 output ov
);
 //-- Numero de bits del contador
 localparam N = 8; 
 
 //-- En contadores de N bits:
 //-- M = 2 ** N
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [N:0] qi = 0;
 
 always @(posedge clk)
   if (rst | ov)
     qi <= 0;
   else
     if (cnt)
       qi <= qi + 1;
       
 assign q = qi;
 
 //-- Comprobar overflow
 assign ov = (qi == M);
     
endmodule
//---- Top entity
module v2040f6 #(
 parameter v2d6186 = "v2d6186.list"
) (
 input ve70352,
 input vd1d1c6,
 input v51a33d,
 input [5:0] va61a55,
 input [31:0] v7d4d05,
 input [5:0] ve2e442,
 input [5:0] v326a87,
 output [31:0] v70ed7b,
 output [31:0] vff4be9
);
 localparam p0 = v2d6186;
 wire [0:5] w1;
 wire [0:5] w2;
 wire w3;
 wire [0:31] w4;
 wire [0:31] w5;
 wire w6;
 wire w7;
 wire [0:5] w8;
 wire [0:31] w9;
 assign w1 = ve2e442;
 assign w2 = v326a87;
 assign w3 = vd1d1c6;
 assign v70ed7b = w4;
 assign vff4be9 = w5;
 assign w6 = ve70352;
 assign w7 = v51a33d;
 assign w8 = va61a55;
 assign w9 = v7d4d05;
 v2040f6_v31ef17 #(
  .Memoria_Registro(p0)
 ) v31ef17 (
  .Read_Reg_1(w1),
  .Read_Reg_2(w2),
  .reset(w3),
  .Read_Data_1(w4),
  .Read_Data_2(w5),
  .clk(w6),
  .write(w7),
  .Write_Reg(w8),
  .Write_Data(w9)
 );
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/

module v2040f6_v31ef17 #(
 parameter Memoria_Registro = 0
) (
 input clk,
 input reset,
 input write,
 input [5:0] Write_Reg,
 input [31:0] Write_Data,
 input [5:0] Read_Reg_1,
 input [5:0] Read_Reg_2,
 output [31:0] Read_Data_1,
 output [31:0] Read_Data_2
);
 // Memory 
 reg [31:0] Mem [0:31];
 
 // Address Memory
 wire [5:0] Read_Reg_1;
 wire [5:0] Read_Reg_2;
 wire [5:0] Write_Reg;
 
 // Input control
 wire reset;
 wire clk;
 wire write;
 
 // Output Read Reg Data
 reg [31:0] Read_Data_1;
 reg [31:0] Read_Data_2;
 
 // Input Write Data
 wire [31:0] Write_Data;
 
 always @(posedge clk or posedge reset)
 begin
     if(reset != 0) begin
         for (i = 1; i < 32; i = i + 1) begin
             Mem[i] <= 32'b0;
         end
     end else if (write == 1 && Write_Reg != 0) begin
         Mem[Write_Reg] <= Write_Data;
     end
 end
 
 integer i;
 
 always @(*) 
 begin
     if (reset != 0) begin
         Read_Data_1 <= 0;
         Read_Data_2 <= 0;
     end else begin
         if(Read_Reg_1 != 0)
             Read_Data_1 <= Mem[Read_Reg_1];
         else
             Read_Data_1 <= 0;
             
         if(Read_Reg_2 != 0)
             Read_Data_2 <= Mem[Read_Reg_2];
         else
             Read_Data_2 <= 0;
     end
 end
 
 // Memory contents read
 // from the Memoria_Registros table
 initial begin
     if (Memoria_Registro) $readmemh(Memoria_Registro, Mem);
 end
endmodule

module main_v9fb13f #(
 parameter opmemory = 0
) (
 input [7:0] in,
 output [5:0] Read_Reg_1
);
 // Address bus (7 bits)
 wire [7:0] in;
 // Instruction Bus (2 bits)
 reg [5:0] Read_Reg_1;
 // Memory Instruction
 reg [5:0] ins [0:11];
 
 always @(*) begin
     Read_Reg_1 <= ins[in];
 end
 
 // Memory contents read
 // from the opmemory table
 initial begin
     if (opmemory) $readmemh(opmemory, ins);
 end
endmodule

module main_v07915a #(
 parameter funcionmemory = 0
) (
 input [7:0] in,
 output [5:0] Read_Reg_2
);
 // Address bus (7 bits)
 wire [7:0] in;
 // Instruction Bus (5 bits)
 reg [5:0] Read_Reg_2;
 // Memory Instruction
 reg [5:0] ins [0:11];
 
 always @(*) begin
     Read_Reg_2 <= ins[in];
 end
 
 // Memory contents read
 // from the funcionmemory table
 initial begin
     if (funcionmemory) $readmemh(funcionmemory, ins);
 end
endmodule

module main_vc54226 #(
 parameter write_data_reg = 0
) (
 input [7:0] in,
 output [31:0] Write_Data
);
 // Address bus (7 bits)
 wire [7:0] in;
 // Instruction Bus (2 bits)
 reg [31:0] Write_Data;
 // Memory Instruction
 reg [31:0] ins [0:11];
 
 always @(*) begin
     Write_Data <= ins[in[7:2]];
 end
 
 // Memory contents read
 // from the write_data_reg table
 initial begin
     if (write_data_reg) $readmemh(write_data_reg, ins);
 end
endmodule

module main_vaf73f3 #(
 parameter write_reg_mem = 0
) (
 input [7:0] in,
 output [5:0] Write_Reg
);
 // Address bus (7 bits)
 wire [7:0] in;
 // Instruction Bus (5 bits)
 reg [5:0] Write_Reg;
 // Memory Instruction
 reg [5:0] ins [0:10];
 
 always @(*) begin
     Write_Reg <= ins[in];
 end
 
 // Memory contents read
 // from the write_reg_mem table
 initial begin
     if (write_reg_mem) $readmemh(write_reg_mem, ins);
 end
endmodule

module main_v98c0e8 (
 input [5:0] in,
 output [7:0] out
);
 assign out = 0 + in;
endmodule

module main_v559759 (
 input [5:0] in,
 output [7:0] out
);
 assign out = 0 + in;
endmodule

module main_v845edd (
 input [5:0] in,
 output [7:0] out
);
 assign out = 0 + in;
endmodule
