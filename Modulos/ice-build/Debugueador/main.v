// Code generated by Icestudio 0.7.0

`default_nettype none

//---- Top entity
module main #(
 parameter v6cbecb = 115200
) (
 input v33fe98,
 input v26bf5e,
 input [31:0] v7426cd,
 input [31:0] v247fb9,
 input [31:0] v4373a2,
 input [31:0] v161422,
 input [7:0] v296755,
 input [7:0] vc8af6a,
 input [7:0] v645d01,
 input [7:0] v20010a,
 output vb3878d,
 output vad9aa5,
 output v932849,
 output [0:7] vinit
);
 localparam p0 = v6cbecb;
 wire w1;
 wire [0:7] w2;
 wire [0:31] w3;
 wire [0:31] w4;
 wire [0:31] w5;
 wire [0:31] w6;
 wire [0:7] w7;
 wire [0:7] w8;
 wire [0:7] w9;
 wire [0:7] w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 assign w1 = v33fe98;
 assign w3 = v7426cd;
 assign w4 = v247fb9;
 assign w5 = v4373a2;
 assign w6 = v161422;
 assign w7 = v296755;
 assign w8 = vc8af6a;
 assign w9 = v645d01;
 assign w10 = v20010a;
 assign vad9aa5 = w11;
 assign vb3878d = w12;
 assign w13 = v33fe98;
 assign w14 = v26bf5e;
 assign w15 = v26bf5e;
 assign v932849 = w20;
 assign w21 = v33fe98;
 assign w13 = w1;
 assign w15 = w14;
 assign w21 = w1;
 assign w21 = w13;
 assign w22 = w19;
 vc6459c #(
  .ved2ada(p0)
 ) v880311 (
  .ve9a78f(w1),
  .v19b8dd(w2),
  .v2da441(w11),
  .v8caaa5(w12),
  .v05e99b(w17),
  .v01321e(w19)
 );
 main_v77551e v77551e (
  .out(w2),
  .W0(w3),
  .W1(w4),
  .W2(w5),
  .W3(w6),
  .B0(w7),
  .B1(w8),
  .B2(w9),
  .B3(w10),
  .clk(w13),
  .Transmision(w14),
  .end_transmision(w16),
  .next(w22)
 );
 v2d00dc v8cb59c (
  .v765971(w15),
  .v675419(w16),
  .v741632(w17),
  .v9a9c84(w18)
 );
 vc4dd08 v0378c7 (
  .v608bd9(w18)
 );
 v43c77c v6c8283 (
  .v4c46bf(w19),
  .v19f572(w20),
  .vcfc79f(w21)
 );
 assign vinit = 8'b00000000;
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/
//---- Top entity
module vc6459c #(
 parameter ved2ada = 115200
) (
 input ve9a78f,
 input [7:0] v19b8dd,
 input v05e99b,
 output v8caaa5,
 output v2da441,
 output v01321e
);
 localparam p1 = ved2ada;
 wire w0;
 wire w2;
 wire [0:7] w3;
 wire w4;
 wire w5;
 wire w6;
 assign v8caaa5 = w0;
 assign w2 = ve9a78f;
 assign w3 = v19b8dd;
 assign w4 = v05e99b;
 assign v2da441 = w5;
 assign v01321e = w6;
 vc6459c_vedebcc #(
  .BAUD(p1)
 ) vedebcc (
  .TX(w0),
  .clk(w2),
  .data(w3),
  .txmit(w4),
  .busy(w5),
  .done(w6)
 );
endmodule

/*-------------------------------------------------*/
/*-- Serial-tx  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Transmisor serie
/*-------------------------------------------------*/

module vc6459c_vedebcc #(
 parameter BAUD = 0
) (
 input clk,
 input [7:0] data,
 input txmit,
 output TX,
 output busy,
 output done
);
 //-- Constantes para obtener las velocidades estándares
 `define B115200 104 
 `define B57600  208
 `define B38400  313
 `define B19200  625
 `define B9600   1250
 `define B4800   2500
 `define B2400   5000
 `define B1200   10000
 `define B600    20000
 `define B300    40000
 
 //-- Constante para calcular los baudios
 localparam BAUDRATE = (BAUD==115200) ? `B115200 : //-- OK
                       (BAUD==57600)  ? `B57600  : //-- OK
                       (BAUD==38400)  ? `B38400  : //-- Ok
                       (BAUD==19200)  ? `B19200  : //-- OK
                       (BAUD==9600)   ? `B9600   : //-- OK
                       (BAUD==4800)   ? `B4800   : //-- OK 
                       (BAUD==2400)   ? `B2400   : //-- OK
                       (BAUD==1200)   ? `B1200   : //-- OK
                       (BAUD==600)    ? `B600    : //-- OK
                       (BAUD==300)    ? `B300    : //-- OK
                       `B115200 ;  //-- Por defecto 115200 baudios
 
 
 //---- GENERADOR DE BAUDIOS
 
 //-- Calcular el numero dde bits para almacenar el divisor
 localparam N = $clog2(BAUDRATE);
 
 //-- Contador para implementar el divisor
 //-- Es un contador modulo BAUDRATE
 reg [N-1:0] divcounter = 0;
 
 //-- Cable de reset para el contador
 //-- Comparador que resetea el contador cuando se alcanza el tope
 //-- o cuando el estado del biestable es 0 (apagado)
 wire reset = ov_gen | (state == 0);
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 //-- Hemos llegado al final
 wire ov_gen = (divcounter == BAUDRATE-1);
 
 
 
 //-- REGISTRO DESPLAZAMIENTO
 
 //-- Salida serie. Inicialmete a 1 (reposo) 
 reg TX = 1;
 
 //-- Registro de desplazamiento de 9 bits
 //-- Inicializado todo a 1s
 reg [8:0] q = 9'h1FF;
 
 //-- La entrada de shift es la salida del generador de baudios
 wire shift = ov_gen;
 
 always @(posedge clk)
   if (txmit_tic)
   //-- Carga del registro
     q <= {data, 1'b0};
     
   else if (shift)
     //-- Desplazamiento. Rellenar con 1 (bit de stop)
     q <= {1'b1, q[8:1]};
     
 //-- Sacar el bit de menor peso por serial-out    
 wire so;
 assign so = q[0];
 
 //-- La salida tx la registramos
 always @(posedge clk)
   TX <= so;
   
 //-- La señal de entrada txmit se pasa por un 
 //-- detector de flancos de subida para generar un tic
 reg q_re = 0;
 wire txmit_tic;
 
 always @(posedge clk)
   q_re <= txmit;
   
 assign txmit_tic = (~q_re & txmit);  
 
 
 
 //-- Estado de transmisor
 //-- 0: Parado
 //-- 1: Ocupado (transmitiendo)
 reg state = 0;
   
 always @(posedge clk)
   //-- Empieza la transmision: ocupado
   if (txmit)
     state <= 1'b1;
     
   //-- Acaba la transmision: libre    
   else if (ov)
     state <= 1'b0;
 
 //-- Contador de bits enviados
 reg [3:0] bits = 0;
 always @(posedge clk)
   //-- Si la cuenta ha terminado... volver a 0
   if (ov)
     bits <= 2'b00;
   else
     if (shift)
       bits <= bits + 1;
 
 //-- Comprobar si se ha transmitido el último bit (overflow)
 //-- 1 bit de start + 8 bits de datos + 1 bit de stop
 wire ov = (bits == 10);
 
 //-- La señal de ocupado es el estado del transmisor
 assign busy = state;
 
 //-- La señal de done es la de overflow pero retrasada un
 //-- periodo de reloj del sistema y que el biestable 
 //-- llegue al estado de parado antes de que se 
 //-- empiece otra transmision
 
 reg done=0;
 
 always @(posedge clk)
   done <= ov;
 
endmodule
//---- Top entity
module v2d00dc (
 input v765971,
 input v9a9c84,
 input v675419,
 output v741632
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign v741632 = w0;
 assign w1 = v765971;
 assign w2 = v9a9c84;
 assign w3 = v675419;
 v2d00dc_v7f68b8 v7f68b8 (
  .o(w0),
  .in0(w1),
  .in1(w2),
  .sel0(w3)
 );
endmodule

/*-------------------------------------------------*/
/*-- Mux 2:1  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Multiplexer 2:1
/*-------------------------------------------------*/

module v2d00dc_v7f68b8 (
 input in0,
 input in1,
 input sel0,
 output o
);
 reg _o;
 
 always @(*) begin
     case(sel0)
         0: _o = in0;
         1: _o = in1;
         default: _o = in0;
     endcase
 end
 
 assign o = _o;
endmodule
//---- Top entity
module vc4dd08 (
 output v608bd9
);
 wire w0;
 assign v608bd9 = w0;
 vc4dd08_v68c173 v68c173 (
  .v(w0)
 );
endmodule

/*-------------------------------------------------*/
/*-- Bit 0  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Assign 0 to the output wire
/*-------------------------------------------------*/

module vc4dd08_v68c173 (
 output v
);
 // Bit 0
 
 assign v = 1'b0;
endmodule
//---- Top entity
module v43c77c #(
 parameter vf18b7a = 50
) (
 input vcfc79f,
 input v4c46bf,
 output v19f572
);
 localparam p0 = vf18b7a;
 wire w1;
 wire w2;
 wire w3;
 assign v19f572 = w1;
 assign w2 = vcfc79f;
 assign w3 = v4c46bf;
 vf91a27 #(
  .v187a47(p0)
 ) vf1e43e (
  .veabfb2(w1),
  .v5688a8(w2),
  .v6e1dd1(w3)
 );
endmodule

/*-------------------------------------------------*/
/*-- flash  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Emitir un pulso de anchura determinada para encender un LED durante un tiempo. 50ms por defecto
/*-------------------------------------------------*/
//---- Top entity
module vf91a27 #(
 parameter v187a47 = 100
) (
 input v5688a8,
 input v6e1dd1,
 output veabfb2,
 output va9e2af
);
 localparam p4 = v187a47;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = v6e1dd1;
 assign veabfb2 = w1;
 assign va9e2af = w2;
 assign w3 = v5688a8;
 vf91a27_v3140f5 #(
  .MS(p4)
 ) v3140f5 (
  .start(w0),
  .p(w1),
  .tic(w2),
  .clk(w3)
 );
endmodule

/*-------------------------------------------------*/
/*-- timer-msec  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Temporizador en milisegundos. La señal p está activa durante el tiempo indicado. Por tic se emite un tic al finalizar
/*-------------------------------------------------*/

module vf91a27_v3140f5 #(
 parameter MS = 0
) (
 input clk,
 input start,
 output p,
 output tic
);
 //localparam MS;
 
 //-- Constante para dividir y obtener una señal de  
 //-- periodo 1ms
 localparam M = 12000;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Cable de reset para el corazon
 wire rst_heart;
 
 //-- Overflow del temporizador del corazon
 wire ov_heart;
 
 //-- Habilitacion del corazon
 wire ena;
 
 //-- Tics del corazon
 wire tic_heart;
 
 //-- Contador del corazon
 reg [N-1:0] heart=0;
 
 always @(posedge clk)
   if (rst_heart)
     heart <= 0;
   else
     heart <= heart + 1;
 
 //-- Overflow del contador
 assign ov_heart = (heart == M-1);
 
 //-- La salida del corazon es la señal de overflow
 assign tic_heart = ov_heart;
 
 //-- Reset del corazon
 assign rst_heart =~ena | ov_heart;
 
 
 
 //--------------------------------------------
 //-- Contador de tics
 //--------------------------------------------
 
 //-- Calcular el numero de bits para almacenar MS tics
 localparam CB = $clog2(MS);
 
 reg [CB-1:0] counter = 0;
 
 //-- Overflow del contador
 wire ov;
 
 //-- Señal de reset del contador
 wire rst;
 
 always @(posedge clk)
 if (rst)
   counter <= 0;
 else
   if (tic_heart)
     counter <= counter + 1;
 
 //-- Evento: cuenta máxima de tics alcanzada
 assign ov = (counter == MS);
 
 //---------------------------------------
 //-- Biestable de estado del timer
 //-- 0: Apagado  
 //-- 1: Funcionando
 reg q = 0;
 
 always @(posedge clk)
   if (start)
     q <= 1'b1;
   else if (rst)
     q<=1'b0;
     
 //-- Lógica de reset
 //En función de la entrada, el estado y  
 // el overflow se inicializa el contador y 
 // se habilita el corazón de tics
 assign rst = ~q | ov | start;
 assign ena = ~rst;
 
 //-- Salida de pulso
 assign p = q;
 
 //-- Salida de tic
 //-- Saca un tic cuando ha finalizado la cuenta
 assign tic = ov;
 
endmodule

module main_v77551e (
 input clk,
 input Transmision,
 input [31:0] W0,
 input [31:0] W1,
 input [31:0] W2,
 input [31:0] W3,
 input [7:0] B0,
 input [7:0] B1,
 input [7:0] B2,
 input [7:0] B3,
 input next,
 output [7:0] out,
 output end_transmision
);
 reg[4:0] nbyte = 0;
 reg[7:0] out;
 reg end_transmision;
 
 always @(*) 
 begin
     case (nbyte)
         0 : out <= 0 & W0[31:24];
         1 : out <= 0 & W0[23:16];
         2 : out <= 0 & W0[15:8];
         3 : out <= 0 & W0[7:0];
         4 : out <= 0 & W1[31:24];
         5 : out <= 0 & W1[23:16];
         6 : out <= 0 & W1[15:8];
         7 : out <= 0 & W1[7:0];
         8 : out <= 0 & W2[31:24];
         9 : out <= 0 & W2[23:16];
         10 : out <= 0 & W2[15:8];
         11 : out <= 0 & W2[7:0];
         12 : out <= 0 & W3[31:24];
         13 : out <= 0 & W3[23:16];
         14 : out <= 0 & W3[15:8];
         15 : out <= 0 & W3[7:0];
         16 : out <= 0 & B0;
         17 : out <= 0 & B1;
         18 : out <= 0 & B2;
         19 : out <= 0 & B3;
         default : out <= 0;
     endcase
 end
 
 always @(posedge clk) 
 begin
   if (nbyte < 20 && Transmision == 1 && next == 1) begin
     nbyte <= nbyte+1;
     end_transmision <= 0;
   end else if (Transmision == 0) begin
     nbyte <= 0;
     end_transmision <= 1;
   end else if (nbyte >= 20) begin
     end_transmision <= 1;
   end
 end
endmodule
